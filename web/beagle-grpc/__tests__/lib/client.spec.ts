import 'isomorphic-fetch'
import { jest, describe, test, expect, beforeAll, afterAll, beforeEach } from '@jest/globals'
import JestMock from 'jest-mock'
import { BeagleGrpcClientOptions } from '../../src/lib/models/client-options'
import { createClient } from '../../src/lib/client'
import { FetchRequest } from '../../src/lib/models/fetch-request'
import * as view from '../../src/lib/view'
import * as request from '../../src/lib/utils/request'
import { ScreenServiceClient } from '../../src/lib/generated-proto/screen_pb_service'

const _MOCK_URL_ = 'http://localhost:6364/my/path'
const _MOCK_GRPC_URL_ = 'http://localhost:9266/grpc'

describe('src/lib/client.ts', () => {
  describe('createClient', () => {
    const originalFetch = global.fetch
    
    let clientOptions: BeagleGrpcClientOptions
    let fetchGrpcViewSpy: JestMock.SpyInstance<Promise<Response>, [name: string, client: ScreenServiceClient, fetchReq: FetchRequest]>
    let getRequestSpy: JestMock.SpyInstance<FetchRequest | null, [requestInfo: RequestInfo]>

    beforeAll(() => {
      fetchGrpcViewSpy = jest.spyOn(view, 'fetchGrpcView').mockImplementation(() => Promise.resolve(new Response()))
      getRequestSpy = jest.spyOn(request, 'getRequest')
      global.fetch = (jest.fn().mockImplementation(() => Promise.resolve(new Response())) as any)
    })

    beforeEach(() => {
      (global.fetch as jest.Mock<any, any[]>).mockClear()
      fetchGrpcViewSpy.mockClear()
      getRequestSpy.mockClear()
      
      clientOptions = {
        proxyAddress: 'http://localhost:6692/',
        redirectGrpcFrom: _MOCK_GRPC_URL_,
        customHttpClient: (jest.fn().mockImplementation(() => new Response()) as any)
      }      
    })

    test('it should create the client (function) using the "ScreenServiceClient" generated by the protocol buffer', () => {
      expect(typeof createClient(clientOptions)).toBe('function')
    })

    describe('fetchGrpcView', () => {
      test('it should use the "fetchGrpcView" when the url matches the grpc origin, using the client generated by the protobuf', () => {
        const url = `${_MOCK_GRPC_URL_}/my-grpc/endpoint`
        createClient(clientOptions)(url)
        
        expect(fetchGrpcViewSpy).toHaveBeenCalledTimes(1)
        expect(getRequestSpy).toHaveReturnedWith({ url })

        const screenServiceClient = new ScreenServiceClient(clientOptions.proxyAddress)
        expect(fetchGrpcViewSpy).toHaveBeenCalledWith('/my-grpc/endpoint', screenServiceClient, { url })
      })

      test('it should not call "fetchGrpcView" when the url does not match the grpc origin', () => {
        const url = `${_MOCK_GRPC_URL_.replace('/grpc', '')}/endpoint`
        createClient(clientOptions)(url)
        
        expect(getRequestSpy).toHaveBeenCalledTimes(1)
        expect(getRequestSpy).toHaveReturnedWith({ url })
        expect(fetchGrpcViewSpy).not.toHaveBeenCalled()
      })

      test('it should not call "fetchGrpcView" when "getRequest" does not return a valid object', () => {
        const url = `${_MOCK_GRPC_URL_.replace('/grpc', '')}/endpoint`
        getRequestSpy = jest.spyOn(request, 'getRequest').mockImplementation(() => null)
        createClient(clientOptions)(url)
        
        expect(getRequestSpy).toHaveBeenCalledTimes(1)
        expect(getRequestSpy).toHaveReturnedWith(null)
        expect(fetchGrpcViewSpy).not.toHaveBeenCalled()

        getRequestSpy.mockRestore()
        getRequestSpy = jest.spyOn(request, 'getRequest')
      })

      test('it should not call "fetchGrpcView" when the "redirectGrpcFrom" is not defined', () => {
        const url = `${_MOCK_GRPC_URL_.replace('/grpc', '')}/endpoint`
        createClient({ ...clientOptions, redirectGrpcFrom: undefined })(url)

        expect(getRequestSpy).toHaveReturnedWith({ url })
        expect(fetchGrpcViewSpy).not.toHaveBeenCalled()
      })
    })

    describe('customHttpClient', () => {
      test('it should use the custom http client when one is provided and the url does not match the grpc origin', () => {
        createClient(clientOptions)(_MOCK_URL_)
        
        expect(clientOptions.customHttpClient).toHaveBeenCalledTimes(1)
        expect(clientOptions.customHttpClient).toHaveBeenCalledWith(_MOCK_URL_)
      })

      test('it should use the custom http client when the "redirectGrpcFrom" is not defined and is provided an url that does not match the grpc origin', () => {
        createClient({ ...clientOptions, redirectGrpcFrom: undefined })(_MOCK_URL_)

        expect(clientOptions.customHttpClient).toHaveBeenCalledTimes(1)
        expect(global.fetch).not.toHaveBeenCalled()
      })
    })

    describe('fetch', () => {
      test('it should use fetch when the custom http client is not defined and is provided an url that does not match the grpc origin', () => {
        createClient({ ...clientOptions, customHttpClient: undefined })(_MOCK_URL_)
        
        expect(clientOptions.customHttpClient).not.toHaveBeenCalled()
        expect(global.fetch).toHaveBeenCalledTimes(1)
        expect(global.fetch).toHaveBeenCalledWith(_MOCK_URL_)
      })

      test('it should use fetch when the "redirectGrpcFrom" and the custom http client are not defined and is provided an url that does not match the grpc origin', () => {
        createClient({ ...clientOptions, redirectGrpcFrom: undefined, customHttpClient: undefined })(_MOCK_URL_)
        
        expect(clientOptions.customHttpClient).not.toHaveBeenCalled()
        expect(global.fetch).toHaveBeenCalledTimes(1)
        expect(global.fetch).toHaveBeenCalledWith(_MOCK_URL_)
      })

      test('it should use fetch when the args does not match the requirements', () => {
        createClient(clientOptions)(null as any)
        
        expect(clientOptions.customHttpClient).not.toHaveBeenCalled()
        expect(global.fetch).toHaveBeenCalledTimes(1)
        expect(global.fetch).toHaveBeenCalledWith(null)
      })
    })

    afterAll(() => {
      (global.fetch as jest.Mock<any, any[]>).mockRestore()
      global.fetch = originalFetch

      fetchGrpcViewSpy.mockRestore()
    })
  })
})